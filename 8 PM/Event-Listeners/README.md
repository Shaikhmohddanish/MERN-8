# JavaScript Event Listeners

## Introduction to Events

Events are actions or occurrences that happen in the browser, which the browser then notifies your code about. These actions can be user-initiated (like clicks or key presses) or generated by the browser itself (like page loading). JavaScript allows you to detect and respond to these events through **event listeners**.

## Event Listener Basics

An event listener is a function that waits for a specific event to occur on a specific element, then executes code in response.

### Adding Event Listeners

The most common way to add an event listener is with the `addEventListener()` method:

```javascript
element.addEventListener(eventType, handlerFunction, options);
```

- `eventType`: A string specifying the event type (e.g., 'click', 'keydown')
- `handlerFunction`: The function to execute when the event occurs
- `options`: An optional object with properties like `capture`, `once`, and `passive`

Example:
```javascript
const button = document.getElementById('myButton');

button.addEventListener('click', function(event) {
    console.log('Button was clicked!');
    console.log('Event object:', event);
});
```

### Removing Event Listeners

To remove an event listener, use the `removeEventListener()` method:

```javascript
// You must provide the same function reference
function handleClick(event) {
    console.log('Button was clicked!');
}

// Add event listener
button.addEventListener('click', handleClick);

// Remove event listener
button.removeEventListener('click', handleClick);
```

Note: Anonymous functions cannot be removed directly, as you cannot reference the same function again:

```javascript
// INCORRECT - This won't work
button.addEventListener('click', function() { console.log('Clicked'); });
button.removeEventListener('click', function() { console.log('Clicked'); });
```

## The Event Object

When an event occurs, the browser creates an **event object** that contains information about the event. This object is automatically passed to your event handler function.

```javascript
button.addEventListener('click', function(event) {
    // 'event' is the event object
    console.log('Event type:', event.type);
    console.log('Target element:', event.target);
    console.log('Current target:', event.currentTarget);
    
    // Coordinates for mouse events
    console.log('Coordinates:', event.clientX, event.clientY);
});
```

Common event object properties:

- `event.type`: The event type (e.g., 'click', 'keydown')
- `event.target`: The element that triggered the event
- `event.currentTarget`: The element the event listener is attached to
- `event.timeStamp`: When the event occurred
- `event.preventDefault()`: Method to prevent the default browser behavior
- `event.stopPropagation()`: Method to stop the event from bubbling up

## Common Event Types

### Mouse Events

- `click`: Fired when an element is clicked
- `dblclick`: Fired when an element is double-clicked
- `mousedown`: Fired when a mouse button is pressed down
- `mouseup`: Fired when a mouse button is released
- `mousemove`: Fired when the mouse moves
- `mouseover`: Fired when the mouse enters an element or its children
- `mouseenter`: Fired when the mouse enters an element (doesn't bubble)
- `mouseleave`: Fired when the mouse leaves an element (doesn't bubble)
- `mouseout`: Fired when the mouse leaves an element or its children
- `contextmenu`: Fired when the right mouse button is clicked

### Keyboard Events

- `keydown`: Fired when a key is pressed down
- `keyup`: Fired when a key is released
- `keypress`: Fired when a key that produces a character is pressed (deprecated)

Key event properties:
```javascript
input.addEventListener('keydown', function(event) {
    console.log('Key:', event.key);         // The key value ('a', 'Enter', etc.)
    console.log('Code:', event.code);       // The physical key ('KeyA', 'Enter', etc.)
    console.log('KeyCode:', event.keyCode); // Legacy numeric code (deprecated)
    
    // Check for modifier keys
    if (event.shiftKey) console.log('Shift is pressed');
    if (event.ctrlKey) console.log('Ctrl is pressed');
    if (event.altKey) console.log('Alt is pressed');
    if (event.metaKey) console.log('Meta key is pressed'); // Windows key or Command key
});
```

### Form Events

- `submit`: Fired when a form is submitted
- `reset`: Fired when a form is reset
- `change`: Fired when an input, select, or textarea's value changes and loses focus
- `input`: Fired immediately when an input or textarea's value changes
- `focus`: Fired when an element receives focus
- `blur`: Fired when an element loses focus
- `select`: Fired when text is selected in an input or textarea

### Document/Window Events

- `load`: Fired when the page and all resources finish loading
- `DOMContentLoaded`: Fired when the HTML is loaded and parsed, but before all resources are loaded
- `resize`: Fired when the window is resized
- `scroll`: Fired when the document or element is scrolled
- `beforeunload`: Fired before the page is unloaded (can be used to show a confirmation dialog)
- `unload`: Fired when the page is being unloaded
- `error`: Fired when a resource fails to load or a JavaScript error occurs

## Event Propagation

When an event occurs on an element, it actually goes through three phases:

1. **Capturing phase**: The event moves from the `document` down to the target element
2. **Target phase**: The event reaches the target element
3. **Bubbling phase**: The event bubbles up from the target element back to the `document`

By default, event listeners are registered for the bubbling phase.

### Event Bubbling

Event bubbling is the process where an event triggered on the deepest element will bubble up through its ancestors in the DOM tree.

```html
<div id="outer">
    <div id="inner">
        Click me
    </div>
</div>
```

```javascript
document.getElementById('outer').addEventListener('click', function() {
    console.log('Outer div clicked');
});

document.getElementById('inner').addEventListener('click', function() {
    console.log('Inner div clicked');
});

// When the inner div is clicked:
// 1. "Inner div clicked" is logged
// 2. "Outer div clicked" is logged
```

### Capturing

To capture events during the capturing phase, set the third parameter of `addEventListener` to `true`:

```javascript
document.getElementById('outer').addEventListener('click', function() {
    console.log('Outer div clicked - Capturing phase');
}, true);

document.getElementById('inner').addEventListener('click', function() {
    console.log('Inner div clicked - Bubbling phase');
});

// When the inner div is clicked:
// 1. "Outer div clicked - Capturing phase" is logged
// 2. "Inner div clicked - Bubbling phase" is logged
```

### Stopping Propagation

You can stop an event from propagating further with `stopPropagation()`:

```javascript
document.getElementById('inner').addEventListener('click', function(event) {
    console.log('Inner div clicked');
    
    // Stop the event from bubbling up
    event.stopPropagation();
});

// Now when the inner div is clicked, "Outer div clicked" will NOT be logged
```

For stopping both capture and bubble phases, use `stopImmediatePropagation()`.

## Preventing Default Behavior

Many events have default behaviors in the browser. For example:

- Clicking a link navigates to the URL
- Submitting a form reloads the page
- Clicking the right mouse button shows a context menu

You can prevent these default behaviors with `preventDefault()`:

```javascript
// Prevent form submission
document.getElementById('myForm').addEventListener('submit', function(event) {
    // Prevent the form from submitting and page reload
    event.preventDefault();
    
    // Perform custom validation or AJAX submission
    validateForm();
});

// Prevent link navigation
document.getElementById('myLink').addEventListener('click', function(event) {
    event.preventDefault();
    console.log('Link clicked, but navigation prevented');
});
```

## Event Delegation

Event delegation is a technique that leverages event bubbling to handle events at a higher level in the DOM rather than attaching event listeners to individual elements.

Benefits:
- Reduces memory usage by having fewer event listeners
- Dynamically created elements automatically get the event handling
- Cleaner, more maintainable code

Example: Handling clicks on list items with a single event listener:

```html
<ul id="taskList">
    <li>Task 1 <span class="delete">×</span></li>
    <li>Task 2 <span class="delete">×</span></li>
    <li>Task 3 <span class="delete">×</span></li>
</ul>
```

```javascript
// Without event delegation (problematic for dynamic elements)
document.querySelectorAll('.delete').forEach(button => {
    button.addEventListener('click', function() {
        this.parentElement.remove();
    });
});

// With event delegation (better approach)
document.getElementById('taskList').addEventListener('click', function(event) {
    if (event.target.classList.contains('delete')) {
        event.target.parentElement.remove();
    }
});
```

## Custom Events

You can create and dispatch your own custom events using the `CustomEvent` constructor.

```javascript
// Create a custom event
const customEvent = new CustomEvent('notification', {
    detail: {
        type: 'success',
        message: 'Operation completed successfully'
    },
    bubbles: true,
    cancelable: true
});

// Dispatch the event on an element
document.getElementById('app').dispatchEvent(customEvent);

// Listen for the custom event
document.addEventListener('notification', function(event) {
    const { type, message } = event.detail;
    showNotification(type, message);
});
```

## Best Practices

1. **Use event delegation** when handling events for multiple similar elements
2. **Remove event listeners** when they're no longer needed (especially important in components that may be removed)
3. **Be cautious with event listeners in loops** to avoid memory leaks
4. **Debounce or throttle** event handlers for events that fire rapidly (like scroll or resize)
5. **Prefer modern event handling** over inline event attributes (`onclick`, etc.)
6. **Use passive event listeners** for scroll performance:
   ```javascript
   element.addEventListener('scroll', handleScroll, { passive: true });
   ```

## Example: Debouncing Event Handlers

Debouncing prevents a function from being called too frequently:

```javascript
function debounce(func, delay) {
    let timeout;
    
    return function() {
        const context = this;
        const args = arguments;
        
        clearTimeout(timeout);
        
        timeout = setTimeout(function() {
            func.apply(context, args);
        }, delay);
    };
}

// Usage
const debouncedResize = debounce(function() {
    console.log('Window resized');
    updateLayout();
}, 250);

window.addEventListener('resize', debouncedResize);
```

## Browser Compatibility

Most event handling methods are well-supported across modern browsers. However, older browsers might have some differences in:

- Event model implementation
- Available event types
- Event object properties
- Default behaviors

When supporting older browsers, consider using feature detection or a polyfill.

## Exercises for Students

1. Create a form validator that provides real-time feedback using input and change events
2. Implement a simple image slider that responds to arrow keys and swipe gestures
3. Build a drag-and-drop interface using mousedown, mousemove, and mouseup events
4. Create a custom event system for communication between different components
5. Implement event delegation on a dynamically generated list with multiple action buttons per item

## Further Reading

- [MDN Web Docs: Introduction to events](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events)
- [MDN Web Docs: EventTarget.addEventListener()](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
- [JavaScript.info: Introduction to browser events](https://javascript.info/introduction-browser-events)
- [CSS-Tricks: Understanding Event Delegation](https://css-tricks.com/understanding-event-delegation/)
